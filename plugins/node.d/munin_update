#!/usr/bin/perl

# Copyright 2020 Christian GÃ¶ttsche
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

# Magic markers
#%# family=auto
#%# capabilities=autoconf

use strict;
use warnings;

use Munin::Plugin;


my $missing_module = undef;
$missing_module = "File::ReadBackwards" unless (eval { require File::ReadBackwards; } );

my $logdir = ($ENV{'logdir'} || $ENV{'MUNIN_LOGDIR'} || '/var/log/munin');
my $logfile = "$logdir/munin-update.log";
my %nodes;
my $total_time;

if ($ARGV[0] and $ARGV[0] eq 'autoconf') {
    if (defined($missing_module)) {
        print "no (missing Perl module: '$missing_module')\n";
    } elsif (! -r $logfile) {
        print "no (cannot find logfile '$logfile')\n";
    } else {
        print "yes\n";
    }
    exit 0;
}

if (defined($missing_module)) {
    die "Failed to run due to missing Perl module '$missing_module'";
}

my $bw = File::ReadBackwards->new($logfile) or
                 die "Cannot read '$logfile': $!";

my $found_starting = 0;
my $found_data = 0;
while(defined(my $log_line = $bw->readline) && $found_starting == 0) {
    if ($log_line =~ /^Starting munin-update$/) {
        $found_starting = 1 unless $found_data == 0;
    } elsif ($log_line =~ /^Munin-update finished for node [\w+.]+;([\w+.]+) \((\d+)\.\d+ sec\)$/) {
        $nodes{$1} = $2;
    } elsif ($log_line =~ /^Munin-update finished \((\d+)\.\d+ sec\)$/) {
        $total_time = $1;
        $found_data = 1;
    }
}


if ($ARGV[0] and $ARGV[0] eq "config") {
    print "graph_title Munin processing time\n",
          "graph_info This graph shows the run time of munin-update.\n",
          "graph_args --base 1000 -l 0\n",
          "graph_scale yes\n",
          "graph_vlabel Time in seconds\n",
          "graph_category munin\n";

    foreach my $node (keys %nodes) {
        my $clean_node = clean_fieldname($node);
        print "$clean_node.label Update time for $node\n";
        print "$clean_node.draw AREASTACK\n";
    }

    print "total_time.label Total update time\n";
    print "total_time.draw LINE1\n";


    exit 0;
}

foreach my $node (keys %nodes) {
    my $clean_node = clean_fieldname($node);
    print "$clean_node.value $nodes{$node}\n";
}

print "total_time.value $total_time\n";
